# [АК]ОС 4. Стек, соглашение о вызовах, пролог, эпилог

## Видео

[[youtube](https://youtu.be/RsyL8UWR42o)]

[[vk](https://vk.com/video-221776054_456239035)]

## Файлики с кодом

1. [lea и умножение](lea.c)
2. [little/big endian](endian.S)
3. [Вызов функции, сохраняем адрес возврата в переменную](call_ret_naive.S)
4. [Вызов функции, сохраняем адрес возврата на стеке](call_ret_stack.S)
5. [Вызов функции call/ret](call_ret.S)
6. [Пролог/эпилог. Смотрим на состояние стека](read_and_add.S)

## Lea для арифметики

Есть простой код, приведенный в файлике [lea](lea.c). Код считывает число и умножает на разные числа.

### -O0

Скомпилируем код без оптимизаций и с комментариями к инструкциям:
`gcc -S -masm=intel -fverbose-asm -O0  lea.c`.  Результат будет в файлике lea.s.
Увидим, что умножение на небольшие числа происходит без использования инструкции mull.
Умножение на 8:
```
sal     eax, 3
```

Умножение на 7:
Такое же, как и на 8, только еще -1
```
sal     eax, 3
sub     eax, edx
```

Умножение на 3:
```
mov     eax, edx
add     eax, eax
add     eax, edx
```

И только для умножения уже на большое число используется imul:
```
imul    eax, eax, 8342
```


### -O3

Скомпилируем код без оптимизаций и с комментариями к инструкциям:
`gcc -S -masm=intel -fverbose-asm -O3  lea.c`. Результат будет в файлике lea.s.

В нем можно увидеть, что больше нет операций сложения, вместо них используется конструкция 

```
	lea	reg, [BREG + IREG * SCALE + OFFSET] // scale = 1, 2, 4, 8
```

Так как для lea в отличие от mov не требуется, чтобы в результате выполнения инструкции получился валидный адрес, то можно использовать эту инструкцию для того, чтобы быстро выполнять арифметические операции.

Умножение на 8:
```
lea     edx, 0[0+rax*8]
```
Умножение на 7:
```
lea     edx, 0[0+rax*8]
sub     edx, eax
```
Умножение на 3:
```
lea     edx, [rax+rax*2]
```


# Endianness

⚠️ Warning! Пример для 32-битного ассемблера, но смысл от этого не меняется.
## Описание

Каждый байт памяти имеет свой адрес. Когда мы говорим, что что-то находится по какому-то адресу, мы имеем в виду, что первый байт этого чего-то лежит по адресу.

Рассмотрим число `10111010 11011101 11110000 00001101` или в 16-ричном представлении `0xBADDF00D`. Так как число имеет размер 32 бита или 4 байта, то нам нужно 4 ячейки памяти, чтобы его сохранить.

У нас есть 2 способа созранить число: более значимые байты (не биты) размещать слева направо или наоброт справа налево. Рассмотрим на примере.

| Endianness \ адрес памяти | 11a0 | 11a1 | 11a2 | 11a3 |
|---------------------------|------|------|------|------|
|     Little Endian         |  0D  |  F0  |  DD  |  BA  |
|     Big Endian            |  BA  |  DD  |  F0  |  0D  |

Little Endian - порядок, в котором менее значимые байты находятся в начале.

Big Endian - порядок, в котором более значимые байты находятся в начале.

Чаще всего используется Little Endian.

| ⚠️ Warning                                                                                                               |
| ------------------------------------------------------------------------------------------------------------------------ |
| В little endian идут в обратном порядке именно байты. То есть число лежит в памяти как `0D F0 DD BA`, а не `D0 0F DD AB` |


Чтобы сложить 2 little endian числа нужно последовательно пройтись байты двух чисел от младнего к старшему и не забыть про перенос через разряд.

## Пример
Рассмотрим простую программу `endian.c`:

```
     .global main
main:
     xor     %eax, %eax
     ret

var:
     .int 0xBADDF00D
```

Скомпилируем: `gcc -m32 endian.c -o endian`. Посмотрим в адрес `var` через objdump: `objdump -d endian`, получим примерно такой вывод:

```
...

000011a0 <var>:
    11a0:	0d f0 dd ba 66       	or     $0x66baddf0,%eax
    11a5:	90                   	nop
    11a6:	66 90                	xchg   %ax,%ax
    11a8:	66 90                	xchg   %ax,%ax
    11aa:	66 90                	xchg   %ax,%ax
    11ac:	66 90                	xchg   %ax,%ax
    11ae:	66 90                	xchg   %ax,%ax

...
```

Можем убедится, что `0xBADDF00D` лежит в памяти ровно так, как описано в табличке выше.

# call/ret

call делает jmp на адрес, который передается аргументом. Кроме этого, call также кладет на стек адрес возврата - адрес, на который надо вернуться после завершения функции. Это адрес следующей инструкции после call. Этот адрес пушится на стек, таким образом адрес вершины стека ровно перед call и сразу после отличаются на 8 байт.

ret делает jmp на адрес возврата. Этот адрес берется с вершины стека. Поэтому важно, чтобы после выполнения функции стек был в таком же состоянии, как и в момент вызова.

# Соглашение о вызовах:

## System V AMD64 ABI

- Целочисленные аргументы передаются последовательно в регистрах: `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`. Если передается более 6 аргументов, то оставшиеся - через стек.
- Вещественные аргументы передаются через регистры `xmm0`...`xmm7`.
- Возвращаемое значение целочисленного типа должно быть сохранено в `rax`, вещественного - в `xmm0`.
- Вызываемая функция обязана сохранять на стеке значения регистров общего назначения `rbx`, `rbp`, и регистры `r12`...`r15`.
- Кроме того, при вызове функции для 64-разрядной архитектуры есть дополнительное требование - перед вызовом функции стек должен быть выровнен по границе 16 байт, то есть необходимо уменьшить значение `rsp` таким образом, оно было кратно 16. Если кроме регистров задействуется стек для передачи параметров, то они должны быть прижаты к нижней выровненной границе стека.
- Для функций гарантируется 128-байтная "красная зона" в стеке ниже регистра `rsp` - область, которая не будет затронута внешним событием, например, обработчиком сигнала. Таким образом, можно задействовать для адресации локальных переменных память до `rsp-128`.
https://github.com/victor-yacovlev/fpmi-caos/tree/master/practice/x86-64

## Выравнивание стека:
Перед `call` стек должен быть выровнен по 16 байтам. Это значит, что адрес вершины стека должен делиться на 16. 

В гдб адрес вершины стека можно проверить так:

```
p $rsp
```

он делится на 16, если последняя цифра 0. Или же можно проверить вот так:
```
p (uint64_t)$rsp%16
```
остаток должен быть 0.

# Пролог/эпилог

Обычно функции принято оформлять специальным образом. В начало добавлять пролог:
```
push    rbp
mov     rbp, rsp
```
В конце функции делают эпилог:
```
mov     rsp, rbp
pop     rbp
```

Это удобно по следующим причинам:
1. После `call` стек становится опять невыровненным, так как при `call` происходит push адреса возврата. Дополнительный `push rbp` опять делает стек корректно выровненным и готовым к новому `call`.
2. Если мы выделяем память на стеке, то для обращения к этой памяти надо отсчитывать расстояние от rsp, например, `mov [rsp + 8], rax` переложит значение из rax на стек. Но так как значение `rsp` меняется от разных команд (push, sub...), то следить за корректностью отступов становится тяжело. Удобнее сразу сохранить исходный адрес вершины стека в другой регистр (rbp) и дальше вести отсчет от него: `mov [rbp-8], rax`. См. [read_and_add.S](read_and_add.S)
3. Так как нужно следить, чтобы в rsp остался исходный адрес, то можно его заранее сохранить в другой регистр, а потом просто из него достать.


 
