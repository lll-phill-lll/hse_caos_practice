Файлики с кодом:
1. [exec](exec.c) - Запускаем `exec` в разных режимах: `execl`, `execlp`... 
2. [run_program](run_program.c) - Как работает `fexecve`
3. [good_program](good_program.c), [evil_program](evil_program.c) - Добрая и злая программы. Используются в `run_program`.
4. [my_bash](my_bash.c) - Самый просто й в мире баш
5. [run_child](run_child.c) - Зачем нужен `cloexec`.
6. [check_fds](check_fds.c) - Пробегаемся по всем файловым дескрипторам и пытаемся что-то прочитать. Используется в `check_fds`
7. [dup_fork](dup_fork.c) - `dup2`.  пишем `./program < file_in > file_out 2>> file_err`


## Execve

`execve(2)` - системный вызов, использующийся для замещения текущей программы какой-то другой. Типичное использование `execve` - создать новый процесс через `fork(2)` и в процессе-ребенке вызвать `exec`, передав в него путь до исполняемого файла. Процесс-ребенок заменится на программу из исполняемого файла и начнется его выполнение. 

Таким образом, например, работает интерпретатор командной строки (shell, bas, zsh) - введенная команда почти всегда приводит к тому, что интерпретатор создает ребенка и в нем запускает исполняемый файл, имя которого передается из командной строки.

`int execve(const char *path, char *const argv[], char *const envp[]);`
`path` - относительный или абсолютный путь до исполняемого файла (`/usr/bin/echo`)
`argv` - аргументы командной строки запускаемого процесса. Это как раз те самые аргументы, которые мы получаем в `int main(int argc, char** argv)`
`envp` - переменные окружения для процесса. Массив строк вида `varname=value`. В main эти значения тоже можно получить, используя такую сигнатуру `int main(int argc, char** argv, char** envp)`.

После успешного срабатывания `execve` виртуальное адресное пространство заменится процесса заменится. И код, находящийся после `execve` не выполнится. Поэтому успешность запуска можно проверять даже без `if`:

```
int status = execve(...);
printf("Execve failed\n");
```


## Exec*

Кроме системного вызова `execve` есть еще библиотечные функции, которые облегчают использование этого системного вызова.

```
int execl(const char *pathname, const char *arg, ... /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);
int execle(const char *pathname, const char *arg, ... /*, (char *) NULL, char *const envp[] */);
int execv(const char *pathname, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[]);
```

### execl
`int execl(const char *pathname, const char *arg, ... /* (char  *) NULL */);`

`l` - list - означает, что аргументы передаются списком. 

Первым аргументом нужно передать абсолютный или относительный путь до исполняемого файла. Остальные аргументы - `argv`. Последний аргумент должен быть NULL.

### execlp

`int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);`

`p` - path - означает, что путь до исполняемого файла передавать не нужно, можно передать только имя.

`execlp` пройдется по всем директориям перечисленным в переменной окружения `PATH` (`echo $PATH`) и будет пытаться запустить `file` из каждой директории до тех пор, пока `execve` не запустится или директории не кончатся.

### execle

`int execle(const char *pathname, const char *arg, ... /*, (char *) NULL, char *const envp[] */);`

`e` - environment - означает, что можно явно указать переменные окружения для запускаемой программы.

Все `exec`, в которых явно не указываются переменные окружения, наследуют эти переменные от вызывающей программы.

### execv*

```
int execv(const char *pathname, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[]);
```

`v` - vector - означает, что аргументы передаются, как массив.

В остальном функции не отличаются от аналогов с `l` вместо `v`.


# dup 

```
#include <unistd.h>
int dup(int oldfd);
```

Системный вызов `dup` используется для того, чтобы создать копию **открытого** файлового дескриптора. Получившийся файловый дескриптор будет иметь номер наименьшего свободного файлового дескриптора.

Например, если сделать `close(STDOUT_FILENO)` и закрыть stdout, а затем сделать `int fd = dup(STDERR_FILENO)`, то значение fd будет 1. Получится, что файловые дескрипторы 1 и 2 будут связаны с одним и тем же файлом и вывод в stdout или stderr приведет к записи в этот файл.

# dup2

```
#include <unistd.h>
int dup2(int oldfd, int newfd);
```

`dup2` работает аналогично `dup`, только в качестве дополнительного аргумента он принимает номер желаемого файлового дескриптора. 

Чтобы повторить пример из `dup` нужно сделать `int fd = dup2(STDERR_FILENO, STDOUT_FILENO)`. При этом `newfd` закрывать предварительно не обязательно. Если `newfd` открыт, то `dup2` его предварительно закроет.



# Зачем нужны dup

Основное предназначение `dup*` - перенаправление потоков. С помощью него как раз реализована поддержка команд вида `./a.out > file`, в данном случае вывод stdout команды попадет в файл file. 

Интерпретатор командной строки (bash, shell, zsh) сделает fork и в ребенке откроет файл file. Дальше с помощью `dup*` заменит файловый дескриптор stdout на файловый дескриптор открытого файла, а после этого сделает `exec`.  Запущенный процесс будет думать, что пишет в stdout, но данные на самом деле будут попадать в файл file, который связан с файловым дескриптором 1.

Пример такого кода в [dup_fork.c](dup_fork.c)