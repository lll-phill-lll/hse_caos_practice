#include <stdio.h>
#include <stdlib.h>

int main() {

    void* p1 = malloc(4096);
    void* p2 = malloc(4096);
    void* p3 = malloc(4096);
    void* p4 = malloc(4096);

    // При таком вызове в strace уже можно увидеть, что память выделяется не brk, а mmap.
    // void* large = malloc(130 * 1024);

    printf("---------\n");
    printf("1: %p\n2: %p\n3: %p\n4: %p\n", p1, p2, p3, p4);
    //  ---------
    //  1: 0x55bb0f0822a0
    //  2: 0x55bb0f0832b0
    //  3: 0x55bb0f0842c0
    //  4: 0x55bb0f0852d0
    //  ---------
    // Ожидали, что разница в адресах будет 0x1000 (4096) как мы и просили, но на самом деле раница 0x1010, то есть 
    // выделилось еще место под дополнительную информацию, с помощтю которой malloc организует хранени памяти
    //  
    printf("---------\n");

    free(p2);

    printf("---------\n");
    printf("1: %p\n2: %p\n3: %p\n4: %p\n", p1, p2, p3, p4);
    //  ---------
    //  1: 0x55bb0f0822a0
    //  2: 0x55bb0f0832b0
    //  3: 0x55bb0f0842c0
    //  4: 0x55bb0f0852d0
    //  ---------
    // Вывод не поменялся несмотря на то, что мы очистили память в p2. free не меняет значение указателя, поэтому после вызова free
    // нельзя по указателю понять, очищена память или нет.
    // Можно использовать комбинацию free(p2), p2 = NULL. В таком случае можно будет проверить значение на null. + нам будет дана дополнительная безопасность
    // Так как делать 2 раза free нельзя, но сделать free, а потом сделать free(null) уже можно. 
    printf("---------\n");

    void* p5 = malloc(4096);

    printf("---------\n");
    printf("1: %p\n2: %p\n3: %p\n4: %p\n5: %p\n", p1, p2, p3, p4, p5);
    //  ---------
    //  1: 0x55bb0f0822a0
    //  2: 0x55bb0f0832b0
    //  3: 0x55bb0f0842c0
    //  4: 0x55bb0f0852d0
    //  ---------
    // Вывод опять остался тем же (вероятно), а значит malloc переиспользовал память, которую мы вернули ему, сделав free(p2)
    printf("---------\n");
}
