# 4 Семинар 29.11.2021 ASM 4

## Файлики с кодом:
- [Работа с lea в более реалистичной среде](lea.S)
- [Простая работа со стеком](stack_simple.S)
- [Работа со стеком с объяснениями](stack_read_add.S)
- Вызвать asm функцию `multiply_add` из C и C++ [asm](multiply_add.S), [c](multiply_add.c), [C++](multiply_add.cpp)
- Вызвать C/C++ функцию `multiply_add` из asm [asm](multiply_add_reversed.S), [c](multiply_add_reversed.c), [C++](multiply_add_reversed.cpp)
- Вызвать printf из asm [asm](simple_printf.S), [c](simple_printf.c)
- Вызвать scanf + printf из asm [asm](call_scanf_printf.S), [c](call_scanf_printf.c)

# Работа со стеком

Стек уже известен нам из АИСД, глобальная идея такая же, как и у std::stack

Стек растет в сторону уменьшения адресов! Чем выше запись, тем меньше у нее адрес

То есть, чтобы сдвинуться выше по стеку, нужно из текущего адреса ВЫЧИТАТЬ

     Содержимое стека  Адреса в памяти

     .                .
     .                .
     .                .
     +----------------+ 0x0000F040
     |                |
     +----------------+ 0x0000F044 <-- вершина стека (на неё указывает %esp)
     |     данные     |
     +----------------+ 0x0000F048
     |     данные     |
     +----------------+ 0x0000F04C
     .                .
     .                .
     .                .
     +----------------+ 0x0000FFF8
     |     данные     |
     +----------------+ 0x0000FFFC
     |     данные     |
     +----------------+ 0x00010000 <-- дно стека

Подробнее можно посмотреть [тут](https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#%D0%A1%D1%82%D0%B5%D0%BA)

# Соглашение о вызовых (cdecl)(32 бита):

При вызове функции есть некторый набор правил (соглашений), который описывает, какие регистры можно менять, как передавать аргументы и тп.

Соглашение о вызовах, с которым мы работаем `cdecl`.

## Регистры:

callee-saved (вызывающая программа ожидает, что после вызова функции значения в этих регистрах не поменяются):

```
    %ebp, %ebx, %esi, %edi, %esp
```

caller-saved (вызывающая программа не рассчитывает на то, что после вызова функции значения в регистрах будут те же, поэтому должна сама позаботиться, если ей нужно значения сохранить):

```
    %eax, %edx, %ecx
```

## Возвращаемое значение:

Возвращаемое значение находится в регистре `%eax` (как при вызове readi32)

## Аргументы функции:

Передаются через стек в обратном порядке перед адресом возврата

# Работа с C и C++ кодом:

## Компиляция и запуск:

Для C:

```
gcc -m32 file.S file.c -o file && ./file
```

Для C++:

```
g++ -m32 file.S file.cpp -o file && ./file
```

Нужно писать объявление функции в C/C++ файле:

Пример для C:

```
int foo(int);
```

Пример для C++:

```
extern "C" int foo(int);
```

в отличие от C, здесь нужно указать extern "C".
Это нужно из-за того, что в C++ в отличие от C
функции с разными аргументами могут иметь одно то же имя: int plus(bool, bool);
Поэтому при линковке будет искаться не символ plus а другой (с информацией о типах аргументов).
Поэтому нужно явно сказать компилятору, чтобы он работал с этой функцией, как бы он это делал в C

# Вызов функций:

Чтобы вызвать функцию из C (например, printf) нужно положить аргументы на стек в оборатном порядке, потому что функция
будет их читать сверху вниз. И после этого сделать call функции. Поэтому нужно, чтобы на верхушке стека был первый аргумент, дальше второй и тд.

Пример для [printf](simple_printf.S)
