# 3 Семинар

## Файлики с кодом:
- [Простое использование "переменной*"](variable.S)
- [Работа с массивом](array.S)
- [Работа с массивом простых структур](persons.S)
- [Простая работа со стеком](stack_simple.S)
- [Работа со стеком cdecl](stack_read_add.S)
- [Простая работа со стеком](stack_simple.S)
- [Работа со стеком с объяснениями](stack_read_add.S)
- Вызвать asm функцию `multiply_add` из C и C++ [asm](multiply_add.S), [c](multiply_add.c), [C++](multiply_add.cpp)
- Вызвать C/C++ функцию `multiply_add` из asm [asm](multiply_add_reversed.S), [c](multiply_add_reversed.c), [C++](multiply_add_reversed.cpp)


На самом деле переменной это называть не совсем корректно, так как это просто метка, которая будет заменена на адрес. Но здесь используется слово переменная, из-за того, что работа с метками похожа работу с привычными переменными


# Работа со стеком

Стек уже известен нам из АИСД, глобальная идея такая же, как и у std::stack

Стек растет в сторону уменьшения адресов! Чем выше запись, тем меньше у нее адрес

То есть, чтобы сдвинуться выше по стеку, нужно из текущего адреса ВЫЧИТАТЬ

     Содержимое стека  Адреса в памяти

     .                .
     .                .
     .                .
     +----------------+ 0x0000F040
     |                |
     +----------------+ 0x0000F044 <-- вершина стека (на неё указывает %esp)
     |     данные     |
     +----------------+ 0x0000F048
     |     данные     |
     +----------------+ 0x0000F04C
     .                .
     .                .
     .                .
     +----------------+ 0x0000FFF8
     |     данные     |
     +----------------+ 0x0000FFFC
     |     данные     |
     +----------------+ 0x00010000 <-- дно стека

Подробнее можно посмотреть [тут](https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#%D0%A1%D1%82%D0%B5%D0%BA)

# Соглашение о вызовых (cdecl)(32 бита):

При вызове функции есть некторый набор правил (соглашений), который описывает, какие регистры можно менять, как передавать аргументы и тп.

Соглашение о вызовах, с которым мы работаем `cdecl`.

## Регистры:

callee-saved (вызывающая программа ожидает, что после вызова функции значения в этих регистрах не поменяются):

```
    %ebp, %ebx, %esi, %edi, %esp
```

caller-saved (вызывающая программа не рассчитывает на то, что после вызова функции значения в регистрах будут те же, поэтому должна сама позаботиться, если ей нужно значения сохранить):

```
    %eax, %edx, %ecx
```

## Возвращаемое значение:

Возвращаемое значение находится в регистре `%eax` (как при вызове readi32)

## Аргументы функции:

Передаются через стек в обратном порядке перед адресом возврата, см [multiply_add](multiply_add.S)

# Работа с C и C++ кодом:

Чтобы asm функцию можно было позвать из c/c++ кода, нужно, чтобы она выполняла соглашение о вызовах.

см multiply_add файлики

## Компиляция и запуск:

Для C:

```
gcc -m32 file.S file.c -o file && ./file
```

Для C++:

```
g++ -m32 file.S file.cpp -o file && ./file
```

Нужно писать объявление функции в C/C++ файле:

Пример для C:

```
int foo(int);
```

Пример для C++:

```
extern "C" int foo(int);
```

в отличие от C, здесь нужно указать extern "C".
Это нужно из-за того, что в C++ в отличие от C
функции с разными аргументами могут иметь одно то же имя: int plus(bool, bool);
Поэтому при линковке будет искаться не символ plus а другой (с информацией о типах аргументов).
Поэтому нужно явно сказать компилятору, чтобы он работал с этой функцией, как бы он это делал в C

# Вызов функций:

Чтобы вызвать функцию из C (например, printf) нужно положить аргументы на стек в оборатном порядке, потому что функция
будет их читать сверху вниз. И после этого сделать call функции. Поэтому нужно, чтобы на верхушке стека был первый аргумент, дальше второй и тд.

Пример для [printf](simple_printf.S)


# Endianness

## Описание

Каждый байт памяти имеет свой адрес. Когда мы говорим, что что-то находится по какому-то адресу, мы имеем в виду, что первый байт этого чего-то лежит по адресу.

Рассмотрим число `10111010 11011101 11110000 00001101` или в 16-ричном представлении `0xBADDF00D`. Так как число имеет размер 32 бита или 4 байта, то нам нужно 4 ячейки памяти, чтобы его сохранить.

У нас есть 2 способа созранить число: более значимые байты (не биты) размещать слева направо или наоброт справа налево. Рассмотрим на примере.

| Endianness \ адрес памяти | 11a0 | 11a1 | 11a2 | 11a3 |
|---------------------------|------|------|------|------|
|     Little Endian         |  0D  |  F0  |  DD  |  BA  |
|     Big Endian            |  BA  |  DD  |  F0  |  0D  |

Little Endian - порядок, в котором менее значимые байты находятся в начале.

Big Endian - порядок, в котором более значимые байты находятся в начале.

Чаще всего используется Little Endian.

| ⚠️ Warning                                                                                                                                      |
|-------------------------------------------------------------------------------------------------------------------------------------------------|
| В little endian идут в обратном порядке именно байты. То есть число лежит в памяти как `0D F0 DD BA`, а не `D0 0F DD AB`                        |


Чтобы сложить 2 little endian числа нужно последовательно пройтись байты двух чисел от младнего к старшему и не забыть про перенос через разряд.

## Пример
Рассмотрим простую программу `endian.c`:

```
     .global main
main:
     xor     %eax, %eax
     ret

var:
     .int 0xBADDF00D
```

Скомпилируем: `gcc -m32 endian.c -o endian`. Посмотрим в адрес `var` через objdump: `objdump -d endian`, получим примерно такой вывод:

```
...

000011a0 <var>:
    11a0:	0d f0 dd ba 66       	or     $0x66baddf0,%eax
    11a5:	90                   	nop
    11a6:	66 90                	xchg   %ax,%ax
    11a8:	66 90                	xchg   %ax,%ax
    11aa:	66 90                	xchg   %ax,%ax
    11ac:	66 90                	xchg   %ax,%ax
    11ae:	66 90                	xchg   %ax,%ax

...
```

Можем убедится, что `0xBADDF00D` лежит в памяти ровно так, как описано в табличке выше.
