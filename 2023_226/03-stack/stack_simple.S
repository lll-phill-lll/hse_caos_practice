// ** Условие **
// Считать 2 числа, положить их на стек и вывести.



//  Содержимое стека  Адреса в памяти
//
//  .                .
//  .                .
//  .                .
//  +----------------+ 0x0000F040
//  |                |
//  +----------------+ 0x0000F044 <-- вершина стека (на неё указывает %esp)
//  |     данные     |
//  +----------------+ 0x0000F048
//  |     данные     |
//  +----------------+ 0x0000F04C
//  .                .
//  .                .
//  .                .
//  +----------------+ 0x0000FFF8
//  |     данные     |
//  +----------------+ 0x0000FFFC
//  |     данные     |
//  +----------------+ 0x00010000 <-- дно стека

    .global main

main:
    // [ return   xxxxx ]
    //   ^esp
    call    readi32
    pushl   %eax
    // [ %eax1, return   xxxxx ]
    //   ^esp

    call    readi32
    pushl   %eax
    // [ %eax2, %eax1, return   xxxxx ]
    //   ^esp

    // Выведем то, что лежит под esp (последнее введенное число)
    movl    (%esp), %eax
    call    writei32

    // Выведем то, что ввели первым с отступом +4.
    // Оступ +4, а не -4 из-за того, что стек растет в сторону уменьшения адресов
    // Поэтому чтобы взять более сратое значение, нужно сходить в память
    // с адресом больше
    movl    4(%esp), %eax
    call    writei32

    popl    %eax
    call    writei32
    // [ %eax1, return   xxxxx ]
    //   ^esp

    popl    %eax
    call    writei32
    // [ return   xxxxx ]
    //   ^esp

    call    finish

