// Посчитать сумму всех цифр в строке переданной через стек

.global count_digits

count_digits:
    // -------- Пролог ---------
    push    %ebp
    mov     %esp, %ebp
    // -------------------------

    // В %edx будет лежать адрес начала нашей строки (адрес первого байта)
    mov     8(%ebp), %edx

    // В %eax будем хранить результирующую сумму
    xor     %eax, %eax

cycle:
    // Признак того, что строка кончилась - байт 0 (\0)
    cmpb    $0, (%edx)
    je      fin

    // Проверяем, что байт под %edx больше или равен 0 (в ascii)
    cmpb    $'0', (%edx)
    jl      increment

    // Проверяем, что байт под %edx меньше или равен 9 (в ascii)
    cmpb    $'9', (%edx)
    jg      increment

    // Здесь мы знаем, что наш байт лежит в диапозине ['0'; '9']
    // Байты %ecx: [0, 0, 0, 0]
    xor     %ecx, %ecx
    // Переложим один байт в нижнюю однобайтовую часть %ecx
    // Байты %ecx: [0, 0, 0, <наш символ>]
    movb    (%edx), %cl
    // Вычтем из нашего байта ascii код нуля, чтобы получить число, а не ascii код числа.
    // Так как значение нашего байта ['0', '9'] или же [48, 57], где 48 - код нуля, 57 - код девяти.
    subb    $'0', %cl
    add     %ecx, %eax

increment:

    incl    %edx
    jmp     cycle

fin:
    // -------- Эпилог ---------
    mov     %esp, %ebp
    pop     %ebp
    // -------------------------


    ret


