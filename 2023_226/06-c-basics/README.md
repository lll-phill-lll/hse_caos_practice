## Файлики с кодом:
- Как работает printf: [printf_example.c](printf_example.c)
- Как работает scanf: [scanf_example.c](scanf_example.c)
- Проворачиваем атаку с переполнением буфера (подбираем пароль): [test_overflow.c](test_overflow.c)
- Делаем реалистичный progress bar: [progress.c](progress.c)
- Сравниваем скорость буферизованного и небуферизованного вывода: [buf_speed.c](buf_speed.c)
- Реальные примеры неожиданного поведения програм при UB: [overflow.cpp](overflow.cpp), [null_dereferencing.cpp](null_dereferencing.cpp)
- Разворачиваем слова в строке (используем арифметику указателей): [reverse_words.c](reverse_words.c)

# Printf/Scanf

Мануалы по командам:

printf:  `man 3 printf`

scanf:   `man 3 scanf`

## Список модификаторов

```
%d — целое число типа int в десятичной системе счисления;
%u — целое число типа unsigned int;
%x — целое число типа int в шестнадцатеричной системе счисления;
%o — целое число типа int в восьмеричной системе счисления;
%hd — целое число типа short в десятичной системе счисления;
%hu — целое число типа unsigned short;
%hx — целое число типа short в шестнадцатеричной системе счисления;
%ld — целое число типа long int в десятичной системе счисления;
%lu — целое число типа unsigned long int;
%lx — целое число типа long int в шестнадцатеричной системе счисления;
%llx — целое число типа long long в шестнадцатеричной системе счисления;
%f — вещественный формат (числа с плавающей точкой типа float);
%lf — вещественный формат двойной точности (числа с плавающей точкой типа double);
%e — вещественный формат в экспоненциальной форме (числа с плавающей точкой типа float в экспоненциальной форме);
%c — символьный формат;
%s — строковый формат.
```

## Специальные символы

```
  \r - carriage return - возвращение каретки в начало строки (использовалось в progress bar)
  \n - перенос строки
  \t - таб
  %20d - напечатать int в окне размером 20. Выравнять по правой стороне.
  %-20d - напечатать int в окне размером 20. Выравнять по левой стороне.
  %0.2f - вывести float число с 2 знаками после запятой
```

## Buffer

printf - line-buffered. Это означает, что он не выводит сразу же, когда мы его вызвали, а копит все в буфере и старается выводить как можно реже, но большим объемом.

Это нужно для того, чтобы как можно реже обращаться к операционной системе. В примере [buf_speed.c](buf_speed.c) мы видим, что буферизованный вывод сработал в 3 раза быстрее.

Сбрасывает буфер (то есть выводит) printf при наступлении специальных условий:

1. Встретился символ переноса строки (\n) - так как printf построчно буферизует
2. Сделали `fflush` - сказали явно сбросить буфер
3. Буфер переполнился
4. Программа завершилась

# Переполнение буфера scanf

[test_overflow.c](test_overflow.c)

```c
#include <stdio.h>
#include <string.h>

int main() {

    char input[9];
    char password[9] = "password";

    // Чтобы избежать ошибки, нужно всегда указывать в scanf размер ввода:
    // scanf("%8s", input);
    scanf("%s", input);

    if (strcmp(input, password) == 0) {
        printf("Access granted\n");
    } else {
        printf("Access denied\n");
    }

}
```

scanf будет считывать пока не закончится ввод.

Если явно ему не сказать считать 8 символов: `scanf("%8s")`, то он будет считывать даже когда input переполнится.

Так как input и password лежат на стеке поряд, то когда input переполнится scanf начнет записывать уже в password.

Поэтому если мы подберем хитро input, например: `aaaaaaaa\0aaaaaaaa\0`, то мы не зная настоящего пароля добьемся вывода `Access granted`.

Проверить: `echo -e 'aaaaaaaa\0aaaaaaaa\0' | ./a.out`

В input поместится `aaaaaaaa\0` - валидная null-terminated строка, дальше input переполнится и password перезатрется, туда поместится следующая часть ввода `aaaaaaaa\0` - та же строка, что и в input.

Дальше strcmp побайтово сравнит строки и вернет 0 (признак равенства строк)


# Опасности UB

## Переполнения инта

[overflow.cpp](overflow.cpp)

```c
  #include <iostream>
  
  int main() {
      char buf[50] = "y";
      for (int j = 0; j < 9; ++j) {
  
          std::cout << (j * 1'000'000'000) << std::endl;
          if (buf[0] == 'x') break;
      }
  }
```


Пример взят отсюда: https://mohitmv.github.io/blog/Shocking-Undefined-Behaviour-In-Action/
https://kristerw.blogspot.com/2017/09/follow-up-on-why-undefined-behavior-may.html

## Пример разного поведения программы при разном уровне оптимизации:

1. g++ -O0 - выводит 9 чисел с integer overflow (UB)
2. g++ -O3 - входит в бесконечный цикл и выводит бесконечно чисел с integer overflow (UB)

Версия: `g++ (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0`

## Почему так происходит?
Компилятор имеет право считать, что в нашем коде никогда не произойдет UB. Поэтому исходя из этого предположения делает какие-то оптимизации.

### Оптимизация 1:
Чтобы избежать умножения j * 1'000'000'000 умножение заменяется на сложение в цикле:
`for (int j = 0; j < 9 * 1'000'000'001; j += 1'000'000'001)` и делает просто `cout << j;`

### Оптимизация 2:
Так как компилятор знает, что у нас точно не будет переполнения (так как у нас не должно быть UB), то он предполагает, что до 3 итерации 
цикла мы не дойдем (где j > 2,147,483,647 (INT_MAX)). Поэтому заменяет `j < 9 * 1'000'000'000` на `true`. Отсюда и бесконечный цикл.
Кстати, если бы мы убрали часть с `buf`, то при компиляции компилятор бы на нас ругался, что у нас UB. Но так он считает, что мы выйдем из цикла.

## Разыменование 0

[null_dereferencing.cpp](null_dereferencing.cpp)

```c
  #include <iostream>
  
  typedef int (*func_t)();
  
  static func_t func;
  
  int call_your_ex() {
      std::cout << "Week of regret" << std::endl;
      return 0;
  }
  
  void never_called() {
      func = call_your_ex;
  }
  
  int main() {
      return func();
  }
```

Пример взят отсюда:
https://kristerw.blogspot.com/2017/09/why-undefined-behavior-may-call-never.html

# Пример разного поведения программы при разном уровне оптимизации:

1. clang++ -O0 - segmentation fault (UB)
2. clang++ -O3 - week of regret (UB)

Версия компилятора: clang version 10.0.0-4ubuntu1 Target: x86_64-pc-linux-gnu


## Почему так происходит?

Компилятор имеет право считать, что в нашем коде никогда не произойдет UB. Поэтому исходя из этого предположения делает какие-то оптимизации.

## В чем проблема
`func_t` - тип указателя на функцию с сигнатурой `int ()`

Так как `func` - `static`, то изначально она инициализированна 0
Дальше мы делаем `func()` - то есть разыменовываем `null` - что является UB.

## Почему вызовется call_your_ex?

В данном простом коде компилятор видит, что значение функции `func` может быть или `0`, или `call_your_ex`.
Дальше у нас есть вызов `func` - значит там не `0`, потому что компилятор действует в предположении, что UB не бывает
А значит единственный вариант, который может быть в `func` - `call_your_ex`. При этом у нас даже есть код, который присваивает `func = call_your_ex`.
Этот код потенциально может быть вызван откуда-то. Поэтому компилятор делает оптимизацию и сразу же делает `return call_your_ex`.


