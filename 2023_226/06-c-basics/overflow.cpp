#include <iostream>

// Пример взят отсюда: https://mohitmv.github.io/blog/Shocking-Undefined-Behaviour-In-Action/
// https://kristerw.blogspot.com/2017/09/follow-up-on-why-undefined-behavior-may.html

// Пример разного поведения программы при разном уровне оптимизации:

// g++ -O0 - выводит 9 чисел с integer overflow (UB)
// g++ -O3 - входит в бесконечный цикл и выводит бесконечно чисел с integer overflow (UB)
// ﻿﻿g++ (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0

// Почему так происходит?
// Компилятор имеет право считать, что в нашем коде никогда не произойдет UB. Поэтому исходя из этого предположения делает какие-то оптимизации.

// Оптимизация 1:
// Чтобы избежать умножения j * 1'000'000'000 умножение заменяется на сложение в цикле:
// for (int j = 0; j < 9 * 1'000'000'001; j += 1'000'000'001)
// и делает cout << j;

// Оптимизация 2:
// Так как компилятор знает, что у нас точно не будет переполнения (так как у нас не должно быть UB), то он знает, что предполагает, что до 3 итерации 
// цикла мы не дойдем (где j > 2,147,483,647 (INT_MAX)). Поэтому заменяет j < 9 * 1'000'000'000 на true. Отсюда и бесконечный цикл.
// Кстати, если бы мы убрали часть с buf, то при компиляции компилятор бы на нас ругался, что у нас UB. Но так он считает, что мы выйдем из цикла.


int main() {
    char buf[50] = "y";
    for (int j = 0; j < 9; ++j) {

        std::cout << (j * 1'000'000'000) << std::endl;
        if (buf[0] == 'x') break;
    }
}
